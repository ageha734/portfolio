import { map } from "./utils/map";
import { prisma } from "./utils/prisma";
import { description } from "./writers/description";
import { mermaid } from "./writers/mermaid";
export var PrismaMarkdown;
(function (PrismaMarkdown) {
    PrismaMarkdown.write = (schema, configParam) => {
        const chapters = PrismaMarkdown.categorize(schema);
        const title = configParam?.title ?? "Prisma Markdown";
        const preface = [
            `# ${title}`,
            "",
            "> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)",
            "",
            ...chapters.map(({ name }) => `- [${name}](#${name.toLowerCase()})`),
        ].join("\n");
        if (chapters.length === 0)
            return preface;
        return [preface, "", chapters.map(PrismaMarkdown.writeChapter).join("\n\n"), ""].join("\n");
    };
    PrismaMarkdown.writeChapter = (chapterParam) => [
        `## ${chapterParam.name}`,
        "",
        ...(chapterParam.diagrams.length > 0 ? [mermaid.write(chapterParam.diagrams)] : []),
        ...(chapterParam.diagrams.length > 0 && chapterParam.descriptions.length > 0 ? [""] : []),
        ...(chapterParam.descriptions.length > 0
            ? [chapterParam.descriptions.map((c) => description.table(c)).join("\n\n")]
            : []),
    ].join("\n");
    PrismaMarkdown.writeDiagram = (diagrams) => mermaid.write(diagrams);
    PrismaMarkdown.writeDescription = (model) => description.table(model);
    PrismaMarkdown.categorize = (schema) => {
        const dict = new Map();
        const modelList = schema.models.filter((model) => !isHidden(model));
        findImplicits(modelList);
        const emplace = (name) => map.take(dict)(name, () => ({
            name,
            descriptions: new Set(),
            diagrams: new Set(),
        }));
        for (const model of modelList) {
            const namespaces = takeTags("namespace")(model);
            if (namespaces.length === 0)
                continue;
            const top = namespaces[0];
            const chapterParam = emplace(top);
            chapterParam.descriptions.add(model);
            chapterParam.diagrams.add(model);
        }
        for (const model of modelList) {
            const namespaces = takeTags("namespace")(model);
            for (const name of namespaces.slice(1)) {
                const section = emplace(name);
                section.descriptions.add(model);
                section.diagrams.add(model);
            }
        }
        for (const model of modelList) {
            const describes = takeTags("describe")(model);
            for (const name of describes) {
                const chapterParam = map.take(dict)(name, () => ({
                    name,
                    descriptions: new Set(),
                    diagrams: new Set(),
                }));
                chapterParam.descriptions.add(model);
            }
        }
        for (const model of modelList) {
            const erdList = takeTags("erd")(model);
            for (const erd of erdList) {
                const chapterParam = map.take(dict)(erd, () => ({
                    name: erd,
                    descriptions: new Set(),
                    diagrams: new Set(),
                }));
                chapterParam.diagrams.add(model);
            }
        }
        for (const model of modelList) {
            const keywords = [
                ...takeTags("namespace")(model),
                ...takeTags("describe")(model),
                ...takeTags("erd")(model),
            ];
            if (keywords.length !== 0)
                continue;
            const basic = map.take(dict)("default", () => ({
                name: "default",
                descriptions: new Set(),
                diagrams: new Set(),
            }));
            basic.descriptions.add(model);
            basic.diagrams.add(model);
        }
        return Array.from(dict.values())
            .filter((c) => !!c.descriptions.size || !!c.diagrams.size)
            .map((chapter) => ({
            name: chapter.name,
            descriptions: Array.from(chapter.descriptions),
            diagrams: Array.from(chapter.diagrams),
        }));
    };
    const takeTags = (kind) => (model) => [
        ...new Set(prisma
            .tagValues(kind)(model)
            .map((str) => str.split(" ")[0])
            .filter((s) => s !== undefined)),
    ];
    const isHidden = (model) => model.documentation?.includes("@hidden") ?? false;
    const findImplicits = (modelList) => {
        const dict = new Map();
        for (const model of modelList)
            for (const field of model.fields) {
                if (field.kind !== "object" || field.isList !== true || field.isUnique !== false)
                    continue;
                const opposite = modelList.find((m) => m.name === field.type);
                const oppositeField = opposite?.fields.find((f) => f.kind === "object" && f.isList && f.type === model.name);
                if (opposite === undefined || oppositeField === undefined || model === opposite)
                    continue;
                const relations = [model, opposite].sort((x, y) => x.name.localeCompare(y.name));
                const table = `_${relations[0]?.name ?? ""}To${relations[1]?.name ?? ""}`;
                if (dict.has(table))
                    continue;
                const newbie = implicitToExplicit(relations[0])(relations[1]);
                modelList.push(newbie);
                dict.set(table, newbie);
            }
    };
    const implicitToExplicit = (x) => (y) => {
        const name = `_${x.name}To${y.name}`;
        const tagger = (kind) => [...new Set([...takeTags(kind)(x), ...takeTags(kind)(y)])].map((value) => `@${kind} ${value}`);
        const description = [
            `Pair relationship table between {@link ${x.dbName ?? x.name}} and {@link ${y.dbName ?? y.name}}`,
            "",
            ...tagger("describe"),
            ...tagger("erd"),
            ...tagger("namespace"),
        ];
        if (description.length === 2)
            description.splice(1, 1);
        const newbie = {
            name,
            dbName: null,
            schema: null,
            fields: [
                {
                    kind: "scalar",
                    name: "A",
                    type: x.primaryKey?.fields?.[0] ?? "String",
                    isRequired: true,
                    isList: false,
                    isUnique: false,
                    isId: false,
                    isReadOnly: false,
                    hasDefaultValue: false,
                },
                {
                    kind: "scalar",
                    name: "B",
                    type: y.primaryKey?.fields?.[0] ?? "String",
                    isRequired: true,
                    isList: false,
                    isUnique: false,
                    isId: false,
                    isReadOnly: false,
                    hasDefaultValue: false,
                },
                {
                    kind: "object",
                    name: x.name,
                    type: x.name,
                    isRequired: true,
                    isList: false,
                    isUnique: false,
                    isId: false,
                    isReadOnly: false,
                    hasDefaultValue: false,
                    relationToFields: [x.primaryKey?.fields?.[0] ?? "id"],
                    relationFromFields: ["A"],
                },
                {
                    kind: "object",
                    name: y.name,
                    type: y.name,
                    isRequired: true,
                    isList: false,
                    isUnique: false,
                    isId: false,
                    isReadOnly: false,
                    hasDefaultValue: false,
                    relationToFields: [y.primaryKey?.fields?.[0] ?? "id"],
                    relationFromFields: ["B"],
                },
            ],
            uniqueFields: [["A", "B"]],
            uniqueIndexes: [],
            primaryKey: null,
            documentation: description.join("\n"),
        };
        x.fields.push({
            kind: "object",
            name,
            type: name,
            isRequired: true,
            isList: true,
            isUnique: false,
            isId: false,
            isReadOnly: false,
            hasDefaultValue: false,
            relationToFields: ["A"],
        });
        y.fields.push({
            kind: "object",
            name,
            type: name,
            isRequired: true,
            isList: true,
            isUnique: false,
            isId: false,
            isReadOnly: false,
            hasDefaultValue: false,
            relationToFields: ["B"],
        });
        return newbie;
    };
})(PrismaMarkdown || (PrismaMarkdown = {}));
