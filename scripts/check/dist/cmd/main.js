#!/usr/bin/env bun
// @bun
import{existsSync as B,readdirSync as M}from"node:fs";import{join as V,relative as W,resolve as X}from"node:path";import{$ as U,spawn as J}from"bun";function I(z=process.cwd()){let q=X(z),H=X("/");while(q!==H){let G=V(q,"package.json"),K=V(q,"turbo.json");if(B(G)&&B(K))return q;q=X(q,"..")}return process.cwd()}function _(){let z=process.argv.slice(2),q="lint",H="ts",G=!1,K=[];for(let N of z)if(N.startsWith("--check-type="))q=N.split("=")[1];else if(N.startsWith("--lint-type="))H=N.split("=")[1];else if(N==="--fix")G=!0;else if(!N.startsWith("--"))K.push(N);return{config:{checkType:q,lintType:H,isFix:G},files:K}}function O(z,q){let H=X(q,z),G=W(q,H),K=[/^apps\/([^/]+)/,/^packages\/([^/]+)/,/^tooling\/([^/]+)/,/^testing\/([^/]+)/,/^scripts\/([^/]+)/];for(let N of K){let Q=N.exec(G);if(Q){let Y=Q[1];if(Y)return Y}}return null}function S(z,q){switch(z){case"tsp":return[V(q,"packages/api/src/schema/")];case"md":return[V(q,"apps/wiki/docs/")];case"shell":{let H=V(q,".docker"),G=[];try{let K=M(H,{recursive:!0}).filter((N)=>N.endsWith(".sh")).map((N)=>V(H,N));G.push(...K)}catch{}return G}case"actions":return[V(q,".github/")];case"textlint":return[V(q,"apps/wiki/docs/")];default:return[V(q,"apps/*/app/"),V(q,"packages/*/src/"),V(q,"tooling/*/src/"),V(q,"testing/*/src/")]}}function R(z){let q=z.replace(/\.(ts|tsx)$/,".test.$1");return B(q)?q:null}function C(z){let q=z.replace(/\.test\.(ts|tsx)$/,".$1");return B(q)?q:null}async function w(z,q){let H=X(q,z),G=V(q,"node_modules",".bin","vitest"),K=R(H);if(!K)console.error(`Error: Test file not found for ${z}`),process.exit(1);await U`${G} run --coverage --coverage.include=${H} --coverage.threshold.lines=100 --coverage.threshold.functions=100 --coverage.threshold.branches=100 --coverage.threshold.statements=100 ${K}`.cwd(q).env({NODE_ENV:"test",PATH:process.env.PATH||""})}async function j(z,q,H){if(q!=="ts")console.error(`Error: --lint-type=${q} is not supported for test. Only --lint-type=ts is supported.`),process.exit(1);let G=z.map((N)=>X(H,N)),K=V(H,"node_modules",".bin","vitest");await U`${K} run ${G}`.cwd(H).env({NODE_ENV:"test",PATH:process.env.PATH||""})}async function v(z,q,H){if(q!=="ts")console.error(`Error: --lint-type=${q} is not supported for coverage. Only --lint-type=ts is supported.`),process.exit(1);let G=V(H,"node_modules",".bin","vitest");if(z.length>0){let K=z.map((N)=>{let Q=X(H,N);if(N.includes(".test."))return C(Q);return Q}).filter((N)=>N!==null);if(K.length===0)console.error("Error: No source files found"),process.exit(1);for(let N of K)await w(W(H,N),H);return}await U`${G} run --coverage`.cwd(H).env({NODE_ENV:"test",PATH:process.env.PATH||""})}async function $(z,q,H,G,K){let N=G.map((Q)=>X(K,Q));if(q==="fmt"){if(H)await U`${z} format ${N}`.cwd(K);else await U`${z} format --check ${N}`.cwd(K);return}if(H)await U`${z} compile ${N}`.cwd(K);else await U`${z} compile ${N} --warn-as-error`.cwd(K)}function b(z,q){if(z==="fmt")return q?"fmt":"fmt:check";return q?"lint:fix":"lint"}async function d(z,q,H,G){if(z.size===0)return;let N=Array.from(z).map((Y)=>`--filter=${Y}`).join(" "),Q=b(q,H);await U`turbo run ${Q} ${N}`.cwd(G)}async function m(z,q,H,G,K){if(G.length===0)return;if(q==="fmt")if(H)await U`${z} format --write ${G}`.cwd(K);else await U`${z} format ${G}`.cwd(K);else if(H)await U`${z} lint --write ${G}`.cwd(K);else await U`${z} lint ${G}`.cwd(K)}async function x(z,q,H,G,K){let N=new Set,Q=[];for(let Y of G){let L=X(K,Y),Z=O(L,K);if(Z)N.add(Z);else Q.push(L)}await d(N,q,H,K),await m(z,q,H,Q,K)}async function g(z,q,H,G){let K=H.map((Q)=>X(G,Q));if(z==="fmt"){if(q)await U`remark ${K} --output`.cwd(G);else await U`remark ${K} --frail --quiet`.cwd(G);return}let N=V(G,"node_modules",".bin","markdownlint-cli2");if(q)await U`${N} --fix ${K}`.cwd(G);else await U`${N} ${K}`.cwd(G)}async function P(z,q,H,G){let K=H.map((Q)=>X(G,Q));if(K.length===0){console.log("No shell files to check");return}if(z==="fmt"){if(q)await U`go run mvdan.cc/sh/v3/cmd/shfmt@v3.12.0 -w ${K}`.cwd(G);else await U`go run mvdan.cc/sh/v3/cmd/shfmt@v3.12.0 -l -d ${K}`.cwd(G);return}let N=K.map((Q)=>W(G,Q));await U`docker run --rm -v ${G}:/work -w /work -v ${G}/node_modules:/work/node_modules koalaman/shellcheck:v0.11.0 ${N}`}async function y(z,q,H,G){if(z==="fmt")console.error("Error: textlint does not support formatting. Use --check-type=lint instead."),process.exit(1);let K=H.map((Q)=>X(G,Q)),N=V(G,"node_modules",".bin","textlint");if(q)await U`${N} --fix ${K}`.cwd(G);else await U`${N} ${K}`.cwd(G)}async function k(z,q,H,G){if(z==="fmt"){let Z=q?[]:["-lint"];Z.push("-gitignore_excludes",...H);let E=J(["go","run","github.com/google/yamlfmt/cmd/yamlfmt@v0.20.0",...Z],{stdout:"inherit",stderr:"inherit"});if(await E.exited,E.exitCode!==0)process.exit(E.exitCode||1);return}let K=J(["go","run","github.com/rhysd/actionlint/cmd/actionlint@v1.7.9"],{stdout:"inherit",stderr:"inherit"}),N=["go","run","github.com/suzuki-shunsuke/ghalint/cmd/ghalint@v1.5.4","run",...H],Q=J(N,{stdout:"inherit",stderr:"inherit"}),[Y,L]=await Promise.all([K.exited.then(()=>K.exitCode),Q.exited.then(()=>Q.exitCode)]);if(Y!==0||L!==0)process.exit(1)}async function T(z,q,H){let{checkType:G,lintType:K}=z,N=V(H,"node_modules",".bin");switch(K){case"tsp":{let Q=V(N,"tsp");await $(Q,G,z.isFix,q,H);break}case"md":{await g(G,z.isFix,q,H);break}case"shell":{await P(G,z.isFix,q,H);break}case"actions":{await k(G,z.isFix,q,H);break}case"textlint":{await y(G,z.isFix,q,H);break}default:{let Q=V(N,"biome");await x(Q,G,z.isFix,q,H)}}}async function A(){let z=I(),{config:q,files:H}=_();try{if(q.checkType==="coverage")await v(H,q.lintType,z);else if(q.checkType==="test")await j(H,q.lintType,z);else{let G=S(q.lintType,z),K=H.length>0?H:G;await T(q,K,z)}process.exit(0)}catch{process.exit(1)}}A();
